def square_lattice_get_nn_indices(index, n, periodic_bounds=False):
    assert n > 0
    neighbors = []

    if not 0 <= index < n * n:
        return neighbors

    x = index % n
    y = index // n

    for xi, yi in [
        (x + 1, y),
        (x - 1, y),
        (x, y + 1),
        (x, y - 1),
    ]:
        if (0 <= xi < n and 0 <= yi < n) or periodic_bounds:
            neighbors.append((yi % n) * n + (xi % n))

    return neighbors


def square_lattice_get_nnn_indices(index, n, periodic_bounds=False):
    assert n > 0
    neighbors = []

    if not 0 <= index < n * n:
        return neighbors

    x = index % n
    y = index // n

    for xi, yi in [
        (x + 1, y + 1),
        (x - 1, y + 1),
        (x + 1, y - 1),
        (x - 1, y - 1),
    ]:
        if (0 <= xi < n and 0 <= yi < n) or periodic_bounds:
            neighbors.append((yi % n) * n + xi % n)

    return neighbors


def triangular_square_lattice_get_nn_indices(index, n, periodic_bounds=False):
    assert n > 0
    assert n % 2 == 0

    neighbors = []

    if not 0 <= index < n * n:
        return neighbors

    x = index % n
    y = index // n

    for xi, yi in [
        (x + 1, y),
        (x - 1, y),
        (x, y + 1),
        (x + (1 if y % 2 == 0 else -1), y + 1),
        (x, y - 1),
        (x + (1 if y % 2 == 0 else -1), y - 1),
    ]:
        if (0 <= xi < n and 0 <= yi < n) or periodic_bounds:
            neighbors.append((yi % n) * n + xi % n)

    return neighbors


def triangular_square_lattice_get_nnn_indices(index, n, periodic_bounds=False):
    assert n > 0
    assert n % 2 == 0

    neighbors = []

    if not 0 <= index < n * n:
        return neighbors

    x = index % n
    y = index // n

    for xi, yi in [
        (x, y + 2),
        (x, y - 2),
        (x + (-1 if y % 2 == 0 else -2), y + 1),
        (x + (2 if y % 2 == 0 else 1), y + 1),
        (x + (-1 if y % 2 == 0 else -2), y - 1),
        (x + (2 if y % 2 == 0 else 1), y - 1),
    ]:
        if (0 <= xi < n and 0 <= yi < n) or periodic_bounds:
            neighbors.append((yi % n) * n + xi % n)

    return neighbors


def triangular_diamond_lattice_get_nn_indices(index, n, periodic_bounds=False):
    assert n > 0

    neighbors = []

    if not 0 <= index < (n + 1) * (n + 1):
        return neighbors

    y, x = triangular_dimond_index_to_row_col(index, n)

    for xi, yi in [
        (x + (0 if y <= n else 1), y - 1),
        (x + (0 if y <= n else 1) - 1, y - 1),
        (x - 1, y),
        (x + 1, y),
        (x + (0 if y < n else -1), y + 1),
        (x + (0 if y < n else -1) + 1, y + 1),
    ]:
        neighbors.append(
            triangular_dimond_row_col_to_index(
                yi, xi, n, periodic_bounds=periodic_bounds
            )
        )

    # filter neg values (may be generated by `triag_dimond_row_col_to_index` if periodic_bounds=False)
    neighbors = [i for i in neighbors if i >= 0]

    return neighbors


def triangular_diamond_lattice_get_nnn_indices(index, n, periodic_bounds=False):
    assert n > 0

    neighbors = []

    if not 0 <= index < (n + 1) * (n + 1):
        return neighbors

    y, x = triangular_dimond_index_to_row_col(index, n)

    for xi, yi in [
        (x + (-1 if y <= n else (0 if y == n + 1 else 1)), y - 2),
        (x + (-1 if y >= n else (0 if y == n - 1 else 1)), y + 2),
        (x + (0 if y <= n else 1) + 1, y - 1),
        (x + (0 if y <= n else 1) - 2, y - 1),
        (x + (0 if y < n else -1) - 1, y + 1),
        (x + (0 if y < n else -1) + 2, y + 1),
    ]:
        neighbors.append(
            triangular_dimond_row_col_to_index(
                yi, xi, n, periodic_bounds=periodic_bounds
            )
        )

    # filter neg values (may be generated by `triag_dimond_row_col_to_index` if periodic_bounds=False)
    neighbors = [i for i in neighbors if i >= 0]

    return neighbors


def triangular_dimond_index_to_row_col(index, n):
    assert n > 0

    row = 0
    col = 0

    for i in [n - abs(j) + 1 for j in range(-n, n + 1)]:
        if index >= i:
            index -= i
            row += 1
        else:
            col = index
            break

    return row, col


def triangular_dimond_row_col_to_index(row, col, n, periodic_bounds=True):
    assert n > 0

    if (
        (row < 0)
        or (col < 0)
        or (row > 2 * n)
        or (row <= n and col > row)
        or (row > n and col > 2 * n - row)
    ):
        if periodic_bounds:
            # transform row/col into valid space
            # as this coordinate space is trash, transform into axis-cartesian coordinates and then transfrom back

            # print("before", row, col)
            cart_row = col + max(row - n, 0)
            cart_col = col + max(n - row, 0)

            # print("cart", cart_row, cart_col)
            cart_row = cart_row % (n + 1)
            cart_col = cart_col % (n + 1)

            row = n - cart_col + cart_row
            col = min(cart_col, cart_row)
            # print("after", row, col)
        else:
            # return invalid
            return -1

    index = 0
    for i in [n - abs(j) + 1 for j in range(-n, row - n)]:
        index += i

    index += col

    return index


def triangular_hexagonal_lattice_get_nn_indices(index, n, periodic_bounds=False):
    assert n > 1
    neighbors = []

    if not 0 <= index < triangular_hexagonal_nr_lattice_sites(n):
        return neighbors

    q, r = triangular_hexagonal_index_to_qr(index, n)

    for qi, ri in [
        (q, r - 1),
        (q + 1, r - 1),
        (q + 1, r),
        (q, r + 1),
        (q - 1, r + 1),
        (q - 1, r),
    ]:
        neighbors.append(
            triangular_hexagonal_qr_to_index(qi, ri, n, periodic_bounds=periodic_bounds)
        )

    # filter neg values (may be generated by `triangular_hexagonal_qr_to_index` if periodic_bounds=False)
    neighbors = [i for i in neighbors if i >= 0]

    return neighbors


def triangular_hexagonal_lattice_get_nnn_indices(index, n, periodic_bounds=False):
    assert n > 1
    neighbors = []

    if not 0 <= index < triangular_hexagonal_nr_lattice_sites(n):
        return neighbors

    q, r = triangular_hexagonal_index_to_qr(index, n)

    for qi, ri in [
        (q + 1, r - 2),
        (q + 2, r - 1),
        (q + 1, r + 1),
        (q - 1, r + 2),
        (q - 2, r + 1),
        (q - 1, r - 1),
    ]:
        neighbors.append(
            triangular_hexagonal_qr_to_index(qi, ri, n, periodic_bounds=periodic_bounds)
        )

    # filter neg values (may be generated by `triangular_hexagonal_qr_to_index` if periodic_bounds=False)
    neighbors = [i for i in neighbors if i >= 0]

    return neighbors


def triangular_hexagonal_index_to_qr(index, n):
    assert n > 1
    assert 0 <= index < triangular_hexagonal_nr_lattice_sites(n)

    index_test = 0
    for r in range(-n + 1, n):
        for q in range(-n + 1, n):
            s = 0 - q - r

            if max(abs(q), abs(r), abs(s)) < n:
                if index_test == index:
                    return q, r
                index_test += 1

    return -1, -1


def triangular_hexagonal_qr_to_index(q, r, n, periodic_bounds=True):
    assert n > 1

    s = 0 - q - r
    if max(abs(q), abs(r), abs(s)) >= n:
        if periodic_bounds:
            # shift back into proper region
            pass
        else:
            return -1

    index = 0
    for r_test in range(-n + 1, n):
        for q_test in range(-n + 1, n):
            s_test = 0 - q_test - r_test

            if max(abs(q_test), abs(r_test), abs(s_test)) < n:
                if q == q_test and r == r_test:
                    return index

                index += 1
    return -1


# too lazy to calculate closed expression for this. Sry
def triangular_hexagonal_nr_lattice_sites(n):
    number = 0

    for r in range(-n + 1, n):
        for q in range(-n + 1, n):
            s = 0 - q - r

            if max(abs(q), abs(r), abs(s)) < n:
                number += 1

    return number


if __name__ == "__main__":
    # print(square_lattice_get_nn_indices(4, 3))
    # print(square_lattice_get_nn_indices(0, 3))

    # print(triangular_dimond_index_to_row_col(0, 2))
    # print(triangular_dimond_index_to_row_col(1, 2))
    # print(triangular_dimond_index_to_row_col(2, 2))
    # print(triangular_dimond_index_to_row_col(3, 2))
    # print(triangular_dimond_index_to_row_col(4, 2))
    # print(triangular_dimond_index_to_row_col(5, 2))
    # print(triangular_dimond_index_to_row_col(6, 2))
    # print(triangular_dimond_index_to_row_col(7, 2))
    # print(triangular_dimond_index_to_row_col(8, 2))

    # print(triangular_dimond_row_col_to_index(0, 0, 2))
    # print(triangular_dimond_row_col_to_index(1, 0, 2))
    # print(triangular_dimond_row_col_to_index(1, 1, 2))
    # print(triangular_dimond_row_col_to_index(2, 0, 2))
    # print(triangular_dimond_row_col_to_index(2, 1, 2))
    # print(triangular_dimond_row_col_to_index(2, 2, 2))
    # print(triangular_dimond_row_col_to_index(3, 0, 2))
    # print(triangular_dimond_row_col_to_index(3, 1, 2))
    # print(triangular_dimond_row_col_to_index(4, 0, 2))

    pass
